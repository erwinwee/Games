<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 24.8.1.2 (Linux)"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="00:00:00"/>
	<style type="text/css">
		@page { size: 8.27in 11.69in; margin: 0.79in }
		p { line-height: 115%; margin-bottom: 0.1in; background: transparent }
		pre { background: transparent }
		pre.western { font-family: "Liberation Mono", monospace; font-size: 10pt }
		pre.cjk { font-family: "NSimSun", monospace; font-size: 10pt }
		pre.ctl { font-family: "Liberation Mono", monospace; font-size: 10pt }
	</style>
</head>
<body lang="en-US" link="#000080" vlink="#800000" dir="ltr"><pre class="western">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;
    &lt;title&gt;Doodle Dash Shooter - Centered Camera&lt;/title&gt;
    &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;&gt;
    &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin&gt;
    &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;style&gt;
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: 'Kalam', cursive;
            background-image:
                linear-gradient(90deg, rgba(200, 200, 200, 0.2) 1px, transparent 1px),
                linear-gradient(rgba(200, 200, 200, 0.2) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
        }

        h1 {
            font-size: 2rem;
            color: #333;
            text-shadow: 2px 2px #fff;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            border: 3px solid #333;
            background-color: #ffffff;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
            cursor: none; /* Hide default cursor over canvas */
            border-radius: 15px;
            max-width: 100%;
            max-height: 100%;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            max-width: 95vw;
            max-height: 75vh;
            cursor: none;
        }
        
        #crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(50, 50, 50, 0.7);
            border-radius: 50%;
            box-sizing: border-box;
            pointer-events: none; 
            display: none; 
            transform: translate(-50%, -50%); 
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(50, 50, 50, 0.7);
        }
        #crosshair::before { 
            left: 50%;
            top: -5px;
            width: 2px;
            height: 30px;
            margin-left: -1px;
        }
        #crosshair::after { 
            top: 50%;
            left: -5px;
            height: 2px;
            width: 30px;
            margin-top: -1px;
        }


        #ui-container {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 1.5rem;
            color: #333;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 1px 1px #fff;
        }
        
        #dash-meter { display: flex; gap: 5px; margin-top: 5px; }
        .dash-bar { width: 30px; height: 10px; background-color: rgba(0,0,0,0.2); border: 2px solid #333; border-radius: 5px; transition: background-color 0.2s; }
        .dash-bar.full { background-color: #3498db; }
        #left-ui { display: flex; flex-direction: column; align-items: flex-start; }
        .instructions { margin-top: 15px; font-size: 1rem; color: #555; text-align: center; }

        #health-container {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #d9534f;
        }
        #health-bar-container {
            width: 150px;
            height: 20px;
            background-color: rgba(0,0,0,0.2);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 2px;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #d9534f;
            border-radius: 6px;
            transition: width 0.2s ease-out;
        }

        #download-btn {
            margin-top: 10px;
            padding: 10px 20px;
            font-family: 'Kalam', cursive;
            font-size: 1rem;
            background-color: #2ecc71;
            color: white;
            border: 2px solid #333;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 3px 3px 0 #333;
            transition: all 0.1s ease-in-out;
        }
        #download-btn:active {
            transform: translate(3px, 3px);
            box-shadow: 0 0 0 #333;
        }


        /* Touch Controls */
        #touch-controls { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: space-between; align-items: flex-end; pointer-events: none; padding: 0 20px; box-sizing: border-box; user-select: none; }
        .control-button { width: 65px; height: 65px; background-color: rgba(50, 50, 50, 0.4); border: 3px solid rgba(255, 255, 255, 0.8); border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-size: 1rem; font-weight: bold; pointer-events: all; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .control-button:active { background-color: rgba(80, 80, 80, 0.6); }
        #action-buttons { display: flex; gap: 15px; align-items: flex-end; }
        #jump-button { width: 80px; height: 80px; font-size: 1.5rem; }
        #joystick-container { position: relative; pointer-events: all; }
        #joystick-base { width: 120px; height: 120px; background-color: rgba(50, 50, 50, 0.3); border: 3px solid rgba(255, 255, 255, 0.5); border-radius: 50%; position: relative; }
        #joystick-stick { width: 60px; height: 60px; background-color: rgba(80, 80, 80, 0.5); border: 3px solid rgba(255, 255, 255, 0.9); border-radius: 50%; position: absolute; top: 30px; left: 30px; transition: transform 0.1s ease-out; }

        @media (max-width: 820px) {
            h1 { font-size: 1.5rem; }
            .instructions { font-size: 0.8rem; }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;h1&gt;Doodle Dash Shooter&lt;/h1&gt;
    &lt;div id=&quot;game-container&quot;&gt;
        &lt;canvas id=&quot;gameCanvas&quot;&gt;&lt;/canvas&gt;
        &lt;div id=&quot;crosshair&quot;&gt;&lt;/div&gt;
        &lt;div id=&quot;ui-container&quot;&gt;
            &lt;div id=&quot;left-ui&quot;&gt;
                &lt;div id=&quot;health-container&quot;&gt;
                    &lt;span&gt;HP&lt;/span&gt;
                    &lt;div id=&quot;health-bar-container&quot;&gt;
                        &lt;div id=&quot;health-bar&quot;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div id=&quot;dash-meter&quot;&gt;
                    &lt;div class=&quot;dash-bar full&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;dash-bar full&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;dash-bar full&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&quot;level-display&quot;&gt;LEVEL: 1&lt;/div&gt;
            &lt;div id=&quot;score&quot;&gt;SCORE: 0&lt;/div&gt;
        &lt;/div&gt;
        &lt;div id=&quot;touch-controls&quot;&gt;
            &lt;div id=&quot;joystick-container&quot;&gt;
                &lt;div id=&quot;joystick-base&quot;&gt;&lt;div id=&quot;joystick-stick&quot;&gt;&lt;/div&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&quot;action-buttons&quot;&gt;
                 &lt;div id=&quot;punch-button&quot; class=&quot;control-button&quot;&gt;PUNCH&lt;/div&gt;
                &lt;div id=&quot;dash-button&quot; class=&quot;control-button&quot;&gt;DASH&lt;/div&gt;
                &lt;div id=&quot;shoot-button&quot; class=&quot;control-button&quot;&gt;SHOOT&lt;/div&gt;
                &lt;div id=&quot;jump-button&quot; class=&quot;control-button&quot;&gt;JUMP&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;instructions&quot;&gt;
        &lt;strong&gt;Controls:&lt;/strong&gt; Aim with Mouse | E to Punch | A/D to Move | W for Jump | Shift to Dash | Click to Shoot
    &lt;/div&gt;
    &lt;button id=&quot;download-btn&quot;&gt;Download Game&lt;/button&gt;

    &lt;script&gt;
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const crosshair = document.getElementById('crosshair');
        
        const VIRTUAL_WIDTH = 800, VIRTUAL_HEIGHT = 600;
        
        function resizeCanvas() { const containerWidth=gameContainer.clientWidth; const containerHeight=gameContainer.clientHeight; const scale=Math.min(containerWidth/VIRTUAL_WIDTH, containerHeight/VIRTUAL_HEIGHT); canvas.style.width=VIRTUAL_WIDTH*scale+'px'; canvas.style.height=VIRTUAL_HEIGHT*scale+'px'; }
        window.addEventListener('resize', resizeCanvas);
        canvas.width = VIRTUAL_WIDTH; canvas.height = VIRTUAL_HEIGHT;
        
        const scoreUI = document.getElementById('score'), dashBars = document.querySelectorAll('.dash-bar'), healthBar = document.getElementById('health-bar'), levelUI = document.getElementById('level-display');
        
        const maxPlayerHealth = 10;
        let score=0, playerHealth=maxPlayerHealth, gameOver=false, animationFrame=0, currentLevel = 1, gameWon = false;
        const gravity=0.6, keys={}, mouse={x:VIRTUAL_WIDTH/2, y:VIRTUAL_HEIGHT/2, down:false};
        let isPlayerInDiscoZone = false;

        // Level Configurations
        const levelSettings = {
            1: { width: 2000, enemies: 10, platformGap: 150 },
            2: { width: 3200, enemies: 20, platformGap: 140 },
            3: { width: 4500, enemies: 36, platformGap: 130 },
            4: { width: 6000, enemies: 50, platformGap: 120 },
            5: { width: 8000, enemies: 70, platformGap: 110 },
        };

        const portal = { x: 0, y: 0, width: 60, height: 80, active: false,
            draw: function() {
                if (!this.active) return;
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                const scale = 1 + Math.sin(animationFrame / 20) * 0.1;
                ctx.scale(scale, scale);
                const grad = ctx.createRadialGradient(0, 0, 10, 0, 0, 40);
                grad.addColorStop(0, `hsla(${(animationFrame * 4) % 360}, 100%, 70%, 1)`);
                grad.addColorStop(0.5, `hsla(${(animationFrame * 4 + 180) % 360}, 100%, 70%, 0.7)`);
                grad.addColorStop(1, `hsla(${(animationFrame * 4) % 360}, 100%, 70%, 0)`);
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        };

        function shakyLine(x1,y1,x2,y2,shake=2){ ctx.beginPath(); ctx.moveTo(x1+(Math.random()-0.5)*shake, y1+(Math.random()-0.5)*shake); ctx.lineTo(x2+(Math.random()-0.5)*shake, y2+(Math.random()-0.5)*shake); ctx.stroke(); }
        const particles=[];
        function createParticles(x,y,count,color,speed){ for(let i=0;i&lt;count;i++){particles.push({x,y,dx:(Math.random()-0.5)*speed,dy:(Math.random()-0.5)*speed,life:20+Math.random()*20,color});} }

        const player = { x: 150, y: 400, width: 40, height: 60, speed: 5, jumpPower: 15, dx: 0, dy: 0, grounded: false, jumpsLeft: 2, shootCooldown: 0, invincibilityTimer: 0, facing: 'right', dashesLeft: 3, dashTimer: 0, isDashing: false, dashSpeed: 20, gunAngle: 0,
            isPunching: false, punchTimer: 0, punchCooldown: 0,
            dashDirection: { x: 1, y: 0 },
            draw: function() {
                if (this.invincibilityTimer &gt; 0 &amp;&amp; Math.floor(this.invincibilityTimer / 5) % 2 === 0) return;
                ctx.save(); ctx.translate(this.x, this.y); ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
                if(this.isPunching){ ctx.strokeStyle = '#3498db'; ctx.lineWidth = 4; }
                if(isPlayerInDiscoZone) { ctx.globalAlpha = 0.5; }
                if(this.isDashing){ctx.globalAlpha=0.5; shakyLine(this.width/2,this.height/2,this.width/2+this.dashDirection.x*50,this.height/2+this.dashDirection.y*50,5); ctx.globalAlpha=1.0;}
                const headX=this.width/2; ctx.beginPath(); ctx.arc(headX,7,10,0,Math.PI*2); ctx.stroke();
                const bodyBob=this.grounded&amp;&amp;this.dx===0?Math.sin(animationFrame/15)*1:0;
                shakyLine(headX,17,headX,40+bodyBob); const armY=28+bodyBob;
                if(!this.grounded){shakyLine(headX,40+bodyBob,headX-10,55);shakyLine(headX,40+bodyBob,headX+5,55);}
                else if(this.dx!==0){const legOffset=Math.sin(animationFrame/5)*12;shakyLine(headX,40+bodyBob,headX-legOffset,60);shakyLine(headX,40+bodyBob,headX+legOffset,60);}
                else{shakyLine(headX,40+bodyBob,headX-10,60);shakyLine(headX,40+bodyBob,headX+10,60);}
                
                ctx.save(); ctx.translate(headX, armY); ctx.rotate(this.gunAngle);
                if (this.isPunching) {
                    const punchExtend = 1 - (this.punchTimer / 15);
                    shakyLine(0, 5, 20, 5); shakyLine(0, -3, 25 * punchExtend, -3);
                    ctx.beginPath(); ctx.arc(30 * punchExtend, -3, 8, 0, Math.PI * 2); ctx.stroke();
                } else {
                    shakyLine(0, 0, 15, 5); shakyLine(0, 0, 18, 0);
                    shakyLine(18, -5, 35, -3); shakyLine(18, 5, 35, 3); shakyLine(35, -3, 35, 3);
                }
                ctx.restore(); ctx.restore();
            }
        };

        const bullets=[], enemyProjectiles=[], BULLET_SPEED=15, SHOOT_DELAY=10;
        function shoot(){ if(player.isPunching || player.shootCooldown&gt;0 || isPlayerInDiscoZone) return; const angle=player.gunAngle; bullets.push({x:player.x+player.width/2+Math.cos(angle)*35,y:player.y+28+Math.sin(angle)*35,dx:Math.cos(angle)*BULLET_SPEED,dy:Math.sin(angle)*BULLET_SPEED,width:5,height:5,life:50}); player.shootCooldown=SHOOT_DELAY;}
        const enemies=[];
        function createEnemy(x,y,onPlatform){
            const rand = Math.random();
            let type;
            if (rand &lt; 0.35) type = 'chaser'; 
            else if (rand &lt; 0.60) type = 'shooter'; 
            else if (rand &lt; 0.75) type = 'cannon'; 
            else if (rand &lt; 0.90) type = 'machine-gunner'; 
            else type = 'disco'; 

            let initialHealth = 3;
            if (type === 'shooter') initialHealth = 2;
            if (type === 'cannon') initialHealth = 8;
            if (type === 'disco') initialHealth = 10;
            if (type === 'machine-gunner') initialHealth = 6;

            enemies.push({x,y,width:40,height: type === 'disco' ? 50 : 40,speed: type === 'chaser' ? 1+Math.random() : 0,dx:1,health:initialHealth,maxHealth:initialHealth,platform:onPlatform, type, shootCooldown: 120 + Math.random() * 60, aimAngle: 0, auraRadius: 180,
                draw: function() {
                    ctx.save(); ctx.translate(this.x, this.y);
                    const barWidth=40,barHeight=6,barX=this.width/2-barWidth/2,barY=-15;
                    ctx.fillStyle='#e74c3c'; ctx.fillRect(barX,barY,barWidth,barHeight);
                    const healthPercentage=this.health/this.maxHealth;
                    ctx.fillStyle='#2ecc71'; ctx.fillRect(barX,barY,barWidth*healthPercentage,barHeight);
                    
                    if (this.type === 'cannon') {
                        ctx.strokeStyle = '#555'; ctx.fillStyle = '#ddd'; ctx.lineWidth = 3;
                        shakyLine(this.width/2 - 15, this.height, this.width/2 + 15, this.height);
                        ctx.beginPath(); ctx.arc(this.width/2, this.height/2 + 10, 18, Math.PI, 0); ctx.fill(); ctx.stroke();
                        ctx.save(); ctx.translate(this.width/2, this.height/2 + 10); ctx.rotate(this.aimAngle);
                        shakyLine(0, 0, 30, 0); shakyLine(30, -5, 30, 5);
                        ctx.restore();
                    } else if (this.type === 'machine-gunner') {
                        ctx.strokeStyle = '#f39c12'; ctx.fillStyle = '#f5d76e'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.arc(this.width/2, this.height/2, 20, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                        ctx.save(); ctx.translate(this.width/2, this.height/2); ctx.rotate(this.aimAngle);
                        shakyLine(-5, -5, 10, -5); shakyLine(-5, 0, 10, 0); shakyLine(-5, 5, 10, 5);
                        shakyLine(10, -5, 10, 5);
                        shakyLine(10, 0, 25, 0);
                        ctx.restore();
                    } else if (this.type === 'disco') {
                        ctx.fillStyle = '#eee'; ctx.strokeStyle = '#888'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(this.width/2, this.height/2, 20, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                        for(let i=0; i&lt;8; i++){ shakyLine(this.width/2 + (Math.random()-0.5)*5, this.height/2 + (Math.random()-0.5)*5, this.width/2 + Math.cos(i*Math.PI/4)*20, this.height/2 + Math.sin(i*Math.PI/4)*20);}
                        ctx.font = '20px Kalam'; ctx.fillStyle = `hsl(${animationFrame*3 % 360}, 100%, 70%)`;
                        ctx.fillText('âª', this.width/2 + 15 + Math.sin(animationFrame/10)*5, this.height/2 - 15);
                        ctx.fillText('â«', this.width/2 - 25 + Math.sin(animationFrame/10 + 2)*5, this.height/2 - 10);
                    } else {
                        const eyeColor = this.type === 'shooter' ? '#3498db' : '#c9302c';
                        ctx.strokeStyle = eyeColor; ctx.fillStyle = '#ffcccc'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.arc(this.width/2, this.height/2, 20, 0, Math.PI*2); ctx.fill();
                        for(let i=0; i&lt;5; i++){ctx.arc(this.width/2+(Math.random()-0.5)*5, this.height/2+(Math.random()-0.5)*5, 20, 0, Math.PI*2);ctx.stroke();}
                        if (this.type === 'shooter') {
                            const pupilX = this.width/2 + (player.x &gt; this.x ? 5 : -5);
                            ctx.fillStyle = eyeColor; ctx.beginPath(); ctx.arc(pupilX, this.height/2-2, 5, 0, Math.PI*2); ctx.fill();
                        } else {
                            shakyLine(this.width/2-10,this.height/2-5,this.width/2-2,this.height/2-10);
                            shakyLine(this.width/2+10,this.height/2-5,this.width/2+2,this.height/2-10);
                        }
                    }
                    ctx.restore();
                }
            });
        }
        const platforms=[];
        let LEVEL_WIDTH = 2000;
        
        function generateLevel(levelNum){ 
            const settings = levelSettings[levelNum];
            LEVEL_WIDTH = settings.width;
            platforms.length = 0;
            enemies.length = 0;
            enemyProjectiles.length = 0;
            bullets.length = 0;
            portal.active = false;
            
            platforms.push({x:0,y:VIRTUAL_HEIGHT-40,width:LEVEL_WIDTH,height:40});
            let currentX=200;
            let enemiesToSpawn = settings.enemies;

            while(currentX&lt;LEVEL_WIDTH-400){
                let y=VIRTUAL_HEIGHT-(100+Math.random()*300);
                let width=150+Math.random()*200;
                const plat={x:currentX,y,width,height:20};
                platforms.push(plat);
                
                if(enemiesToSpawn &gt; 0 &amp;&amp; Math.random() &gt; 0.2) {
                    createEnemy(plat.x+plat.width/2,plat.y-40,plat);
                    enemiesToSpawn--;
                }
                currentX+=width + settings.platformGap + Math.random()*150;
            }
            while (enemiesToSpawn &gt; 0) {
                 const randomPlatform = platforms[Math.floor(Math.random() * (platforms.length -1)) + 1];
                 createEnemy(randomPlatform.x + randomPlatform.width/2, randomPlatform.y-40, randomPlatform);
                 enemiesToSpawn--;
            }

            const lastPlatform = platforms[platforms.length - 1];
            portal.x = lastPlatform.x + lastPlatform.width / 2 - portal.width / 2;
            portal.y = lastPlatform.y - portal.height - 10;
        }

        function drawPlatforms(){ ctx.strokeStyle='#333';ctx.fillStyle='#fdfdfd';ctx.lineWidth=2;platforms.forEach(p=&gt;{ctx.fillRect(p.x,p.y,p.width,p.height);for(let i=0;i&lt;5;i++){ctx.strokeRect(p.x+(Math.random()-0.5)*2,p.y+(Math.random()-0.5)*2,p.width,p.height);}}); }
        const camera={x:0,y:0,update:function(){this.x=player.x-VIRTUAL_WIDTH/2;if(this.x&lt;0)this.x=0;if(this.x&gt;LEVEL_WIDTH-VIRTUAL_WIDTH)this.x=LEVEL_WIDTH-VIRTUAL_WIDTH;}};
        
        function resetGame(){ player.x=150;player.y=400;playerHealth=maxPlayerHealth;score=0;gameOver=false;gameWon=false;currentLevel=1;generateLevel(currentLevel);updateUI(); if(!animationFrame) gameLoop();}
        
        function nextLevel() {
            currentLevel++;
            if (levelSettings[currentLevel]) {
                 player.x = 150;
                 player.y = 400;
                 player.dy = 0;
                 playerHealth = maxPlayerHealth;
                 generateLevel(currentLevel);
                 updateUI();
                 mouse.x = VIRTUAL_WIDTH / 2;
                 mouse.y = VIRTUAL_HEIGHT / 2;
                 const rect = canvas.getBoundingClientRect();
                 const scaleX = canvas.width / rect.width;
                 const scaleY = canvas.height / rect.height;
                 crosshair.style.left = `${mouse.x / scaleX}px`;
                 crosshair.style.top = `${mouse.y / scaleY}px`;
            } else {
                gameWon = true;
            }
        }

        let jumpKeyPressed = false, dashKeyPressed = false, punchKeyPressed = false;
        function update() {
            if (gameOver || gameWon) { if(keys['r'] || keys['R']) resetGame(); return; }
            animationFrame++;
            isPlayerInDiscoZone = false;
            enemies.forEach(e =&gt; { if (e.type === 'disco' &amp;&amp; Math.hypot(player.x - e.x, player.y - e.y) &lt; e.auraRadius) { isPlayerInDiscoZone = true; } });
            
            if (isPlayerInDiscoZone &amp;&amp; player.invincibilityTimer &lt;= 0) { playerHealth -= 0.02; updateUI(); if(playerHealth&lt;=0) gameOver=true;}

            if (player.shootCooldown &gt; 0) player.shootCooldown--;
            if (player.invincibilityTimer &gt; 0) player.invincibilityTimer--;
            if (player.punchCooldown &gt; 0) player.punchCooldown--;

            let worldMouseX=mouse.x+camera.x; let worldMouseY=mouse.y+camera.y;
            player.gunAngle=Math.atan2(worldMouseY-(player.y+28),worldMouseX-(player.x+player.width/2));
            if (!player.isDashing &amp;&amp; !player.isPunching) player.facing=(worldMouseX&gt;player.x+player.width/2)?'right':'left';
            if (mouse.down) shoot();
            
            if (player.isPunching) {
                const parryHitbox = { x: player.x, y: player.y, width: player.width, height: player.height };
                for (let i = enemyProjectiles.length - 1; i &gt;= 0; i--) {
                    const proj = enemyProjectiles[i];
                    if (!proj.deflected &amp;&amp; proj.parryable &amp;&amp; isColliding(parryHitbox, proj)) {
                        proj.deflected = true; const reflectAngle = player.gunAngle;
                        proj.dx = Math.cos(reflectAngle) * proj.speed * 1.5; proj.dy = Math.sin(reflectAngle) * proj.speed * 1.5;
                    }
                }
                if (player.punchTimer-- &lt;= 0) player.isPunching = false;
            } else if (player.isDashing) {
                player.x += player.dashDirection.x * player.dashSpeed;
                player.y += player.dashDirection.y * player.dashSpeed;
                if (player.dashTimer-- &lt;= 0) player.isDashing = false;
            } else {
                if ((keys['e'] || keys['punch']) &amp;&amp; !punchKeyPressed &amp;&amp; player.punchCooldown &lt;= 0 &amp;&amp; !isPlayerInDiscoZone) { player.isPunching = true; player.punchTimer = 15; player.punchCooldown = 45; punchKeyPressed = true; }
                if (!keys['e'] &amp;&amp; !keys['punch']) punchKeyPressed = false;
                if ((keys['Shift'] || keys['dash']) &amp;&amp; !dashKeyPressed &amp;&amp; player.dashesLeft &gt; 0) {
                    player.isDashing = true; player.dashesLeft--; player.dashTimer = 8; player.invincibilityTimer = 10; dashKeyPressed = true; updateUI();
                    let dashDir = { x: 0, y: 0 };
                    if (joystick.active &amp;&amp; (joystick.dirX !== 0 || joystick.dirY !== 0)) { dashDir = { x: joystick.dirX, y: joystick.dirY }; } 
                    else { if (keys['a'] || keys['ArrowLeft']) dashDir.x = -1; if (keys['d'] || keys['ArrowRight']) dashDir.x = 1; if (keys['w'] || keys['ArrowUp']) dashDir.y = -1; if (keys['s'] || keys['ArrowDown']) dashDir.y = 1; }
                    if (dashDir.x === 0 &amp;&amp; dashDir.y === 0) { dashDir.x = player.facing === 'right' ? 1 : -1; }
                    const mag = Math.sqrt(dashDir.x**2 + dashDir.y**2);
                    if (mag &gt; 0) { player.dashDirection = { x: dashDir.x / mag, y: dashDir.y / mag }; }
                    createParticles(player.x+player.width/2, player.y+player.height/2, 20, '#3498db', 8);
                }
                if (!keys['Shift'] &amp;&amp; !keys['dash']) dashKeyPressed = false;
                let moveX = joystick.active ? joystick.dirX : 0;
                if (!joystick.active) { if (keys['a'] || keys['ArrowLeft']) moveX = -1; else if (keys['d'] || keys['ArrowRight']) moveX = 1; }
                player.dx = moveX * player.speed; player.x += player.dx;
                if ((keys['w'] || keys['ArrowUp'])) { if (!jumpKeyPressed &amp;&amp; player.jumpsLeft &gt; 0) { player.dy = -player.jumpPower; player.jumpsLeft--; if(player.jumpsLeft === 0) createParticles(player.x+player.width/2, player.y+player.height, 15, '#95a5a6', 5); jumpKeyPressed = true; player.grounded = false; } } 
                else { jumpKeyPressed = false; }
                player.dy += gravity; player.y += player.dy;
            }

            let onPlatform = false;
            platforms.forEach(p =&gt; { if (player.x &lt; p.x + p.width &amp;&amp; player.x + player.width &gt; p.x &amp;&amp; player.y &lt; p.y + p.height &amp;&amp; player.y + player.height &gt; p.y) { if (!player.isDashing &amp;&amp; player.dy &gt;= 0 &amp;&amp; player.y + player.height - player.dy &lt;= p.y + 1) { player.y = p.y - player.height; player.dy = 0; onPlatform = true; player.jumpsLeft = 2; if (player.dashesLeft &lt; 3) { player.dashesLeft = 3; updateUI(); } } } });
            player.grounded = onPlatform;

            for(let i=bullets.length-1;i&gt;=0;i--){const b=bullets[i];b.x+=b.dx;b.y+=b.dy;if(--b.life&lt;=0||b.x&lt;camera.x||b.x&gt;camera.x+VIRTUAL_WIDTH)bullets.splice(i,1);}
            for(let i=enemyProjectiles.length-1;i&gt;=0;i--){const p=enemyProjectiles[i];p.x+=p.dx;p.y+=p.dy;if(--p.life&lt;=0||p.x&lt;camera.x||p.x&gt;camera.x+VIRTUAL_WIDTH)enemyProjectiles.splice(i,1);}
            
            enemies.forEach(e =&gt; {
                const distToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
                if (e.type === 'chaser') { e.x += e.dx * e.speed; if(e.platform &amp;&amp; (e.x &lt; e.platform.x || e.x + e.width &gt; e.platform.x + e.platform.width)) e.dx *= -1; }
                else if (e.type === 'shooter') { if (e.shootCooldown-- &lt;= 0 &amp;&amp; distToPlayer &lt; 400) { const angle = Math.atan2(player.y - e.y, player.x - e.x); const speed = 4; enemyProjectiles.push({type: 'bullet', x: e.x+e.width/2, y: e.y+e.height/2, width: 12, height: 12, dx: Math.cos(angle)*speed, dy: Math.sin(angle)*speed, life: 150, speed, deflected: false, parryable: true, damage: 1}); e.shootCooldown = 120 + Math.random() * 60; } }
                else if (e.type === 'cannon') { e.aimAngle = Math.atan2((player.y - 10) - (e.y + e.height/2), player.x - (e.x + e.width/2)); if (e.shootCooldown-- &lt;= 0 &amp;&amp; distToPlayer &lt; 500) { const speed = 3.5; enemyProjectiles.push({type: 'cannonball', x: e.x+e.width/2 + Math.cos(e.aimAngle)*30, y: e.y+e.height/2+10 + Math.sin(e.aimAngle)*30, width: 20, height: 20, dx: Math.cos(e.aimAngle)*speed, dy: Math.sin(e.aimAngle)*speed, life: 180, speed, deflected: false, parryable: true, damage: 2}); e.shootCooldown = 180 + Math.random() * 80; } }
                else if (e.type === 'machine-gunner') {
                    e.aimAngle = Math.atan2((player.y) - (e.y + e.height/2), player.x - (e.x + e.width/2));
                    if (e.shootCooldown &gt; 0) e.shootCooldown--;
                    if (distToPlayer &lt; 900 &amp;&amp; e.shootCooldown &lt;= 0) { // Range Doubled
                        const angle = e.aimAngle + (Math.random() - 0.5) * 0.2;
                        const speed = 8;
                        const startX = e.x + e.width/2 + Math.cos(angle)*25;
                        const startY = e.y + e.height/2 + Math.sin(angle)*25;
                        enemyProjectiles.push({type: 'mg-bullet', x: startX, y: startY, width: 10, height: 4, dx: Math.cos(angle)*speed, dy: Math.sin(angle)*speed, life: 120, speed, deflected: false, parryable: false, damage: 0.5});
                        e.shootCooldown = 10;
                    }
                }
            });

            particles.forEach((p,i)=&gt;{p.x+=p.dx;p.y+=p.dy;p.life--;if(p.life&lt;=0)particles.splice(i,1);});
            for(let i=bullets.length-1;i&gt;=0;i--){for(let j=enemies.length-1;j&gt;=0;j--){if(isColliding(bullets[i],enemies[j])){enemies[j].health--;bullets.splice(i,1);if(enemies[j].health&lt;=0){
                createParticles(enemies[j].x + enemies[j].width/2, enemies[j].y + enemies[j].height/2, 30, '#c0392b', 6);
                enemies.splice(j,1);score+=100;updateUI();
                if (enemies.length === 0) portal.active = true;
                }break;}}}
            
            for(let i=enemyProjectiles.length-1;i&gt;=0;i--){
                const p = enemyProjectiles[i];
                if (p.deflected) {
                    let hitSomething = false;
                    for (let j = enemies.length - 1; j &gt;= 0; j--) {
                        if (isColliding(p, enemies[j])) {
                            const explosionRadius = p.type === 'cannonball' ? 120 : 80; const explosionColor = p.type === 'cannonball' ? '#ff6b6b' : '#f39c12';
                            createParticles(p.x, p.y, 60, explosionColor, 8);
                            enemies.forEach(enemyInRadius =&gt; { if (Math.hypot(p.x - enemyInRadius.x, p.y - enemyInRadius.y) &lt; explosionRadius) enemyInRadius.health -= 3; });
                            for (let k = enemies.length - 1; k &gt;= 0; k--) { if (enemies[k].health &lt;= 0) { 
                                createParticles(enemies[k].x + enemies[k].width/2, enemies[k].y + enemies[k].height/2, 30, '#c0392b', 6);
                                enemies.splice(k, 1); score += 150; updateUI(); 
                                if (enemies.length === 0) portal.active = true;
                            } }
                            hitSomething = true; break; 
                        }
                    }
                     if (hitSomething) enemyProjectiles.splice(i, 1);
                } else { if (!player.isPunching &amp;&amp; player.invincibilityTimer &lt;= 0 &amp;&amp; isColliding(p, player)) { takeDamage(p.damage); enemyProjectiles.splice(i, 1); break; } }
            }
            if(!player.isPunching &amp;&amp; player.invincibilityTimer&lt;=0){enemies.forEach(e=&gt;{if(e.type==='chaser'&amp;&amp;isColliding(player,e))takeDamage(1);});}
            if(player.y&gt;VIRTUAL_HEIGHT){takeDamage(2);player.x=150;player.y=400;player.dy=0;}

            if (portal.active &amp;&amp; isColliding(player, portal)) {
                nextLevel();
            }

            camera.update();
        }
        function takeDamage(amount){if(player.invincibilityTimer&gt;0)return;playerHealth-=amount;player.invincibilityTimer=120;updateUI();if(playerHealth&lt;=0)gameOver=true;}
        function isColliding(rect1,rect2){return rect1.x&lt;rect2.x+rect2.width&amp;&amp;rect1.x+rect1.width&gt;rect2.x&amp;&amp;rect1.y&lt;rect2.y+rect2.height&amp;&amp;rect1.y+rect1.height&gt;rect2.y;}
        
        function updateUI(){
            const healthPercentage = Math.max(0, (playerHealth / maxPlayerHealth) * 100);
            healthBar.style.width = `${healthPercentage}%`;
            scoreUI.textContent=`SCORE: ${score}`;
            levelUI.textContent = `LEVEL: ${currentLevel}`;
            dashBars.forEach((bar,i)=&gt;{if(i&lt;player.dashesLeft)bar.classList.add('full');else bar.classList.remove('full');});
        }

        function draw(){
            ctx.clearRect(0,0,canvas.width,canvas.height); ctx.save(); ctx.translate(-camera.x,-camera.y);
            drawPlatforms();
            portal.draw();
            enemies.forEach(e =&gt; {
                if (e.type === 'disco') {
                    const radius = e.auraRadius;
                    const grad = ctx.createRadialGradient(e.x + e.width/2, e.y + e.height/2, radius * 0.2, e.x + e.width/2, e.y + e.height/2, radius);
                    grad.addColorStop(0, `hsla(${animationFrame*2 % 360}, 100%, 60%, 0.3)`);
                    grad.addColorStop(1, `hsla(${(animationFrame*2+180) % 360}, 100%, 60%, 0)`);
                    ctx.fillStyle = grad;
                    ctx.fillRect(e.x + e.width/2 - radius, e.y + e.height/2 - radius, radius*2, radius*2);
                }
            });
            particles.forEach(p=&gt;{ctx.fillStyle=p.color;ctx.globalAlpha=p.life/40;ctx.fillRect(p.x,p.y,3,3);ctx.globalAlpha=1;});
            player.draw();
            bullets.forEach(b=&gt;{ctx.fillStyle='#333';ctx.beginPath();ctx.arc(b.x,b.y,b.width,0,Math.PI*2);ctx.fill();});
            enemyProjectiles.forEach(p=&gt;{
                if (p.type === 'cannonball') {
                    ctx.fillStyle = p.deflected ? '#20bf6b' : '#3d3d3d'; ctx.strokeStyle = '#2d2d2d'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.width/2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                } else if (p.type === 'mg-bullet') {
                    ctx.fillStyle = '#f39c12';
                    ctx.fillRect(p.x-p.width/2,p.y-p.height/2,p.width,p.height);
                } else {
                    ctx.fillStyle=p.deflected?'#2ecc71':'#e74c3c';ctx.lineWidth=2;
                    ctx.beginPath();ctx.strokeRect(p.x-p.width/2,p.y-p.height/2,p.width,p.height);
                    ctx.fillRect(p.x-p.width/2,p.y-p.height/2,p.width,p.height);
                }
            });
            enemies.forEach(e=&gt;e.draw());
            ctx.restore();
            if(gameOver){ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle='white';ctx.textAlign='center';ctx.font='70px Kalam';ctx.fillText('GAME OVER',canvas.width/2,canvas.height/2-20);ctx.font='30px Kalam';ctx.fillText(`Final Score: ${score}`,canvas.width/2,canvas.height/2+30);ctx.font='20px Kalam';ctx.fillText('Press &quot;R&quot; to Restart',canvas.width/2,canvas.height/2+70);}
            if(gameWon){ctx.fillStyle='rgba(46, 204, 113, 0.8)';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.fillStyle='white';ctx.textAlign='center';ctx.font='70px Kalam';ctx.fillText('YOU WIN!',canvas.width/2,canvas.height/2-20);ctx.font='30px Kalam';ctx.fillText(`Final Score: ${score}`,canvas.width/2,canvas.height/2+30);ctx.font='20px Kalam';ctx.fillText('Press &quot;R&quot; to Play Again',canvas.width/2,canvas.height/2+70);}

        }
        function gameLoop(){
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        window.addEventListener('keydown',e=&gt;{keys[e.key]=true;});
        window.addEventListener('keyup',e=&gt;{keys[e.key]=false;});
        
        let aimTouchId = null;
        function updateAimPosition(clientX, clientY) { const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; mouse.x = (clientX - rect.left) * scaleX; mouse.y = (clientY - rect.top) * scaleY; crosshair.style.left = `${clientX - rect.left}px`; crosshair.style.top = `${clientY - rect.top}px`; crosshair.style.display = 'block'; }
        canvas.addEventListener('mousedown',e=&gt;{updateAimPosition(e.clientX, e.clientY); mouse.down=true;});
        canvas.addEventListener('mouseup',e=&gt;{mouse.down=false;});
        canvas.addEventListener('mousemove',e=&gt;{updateAimPosition(e.clientX, e.clientY);});
        gameContainer.addEventListener('mouseleave',()=&gt;{crosshair.style.display='none';});
        gameContainer.addEventListener('mouseenter',()=&gt;{crosshair.style.display='block';});
        document.getElementById('jump-button').addEventListener('touchstart',e=&gt;{e.preventDefault();keys['w']=true;},{passive:false});
        document.getElementById('jump-button').addEventListener('touchend',e=&gt;{e.preventDefault();keys['w']=false;});
        document.getElementById('shoot-button').addEventListener('touchstart',e=&gt;{e.preventDefault();mouse.down=true;},{passive:false});
        document.getElementById('shoot-button').addEventListener('touchend',e=&gt;{e.preventDefault();mouse.down=false;});
        document.getElementById('dash-button').addEventListener('touchstart',e=&gt;{e.preventDefault();keys['dash']=true;},{passive:false});
        document.getElementById('dash-button').addEventListener('touchend',e=&gt;{e.preventDefault();keys['dash']=false;});
        document.getElementById('punch-button').addEventListener('touchstart', e =&gt; { e.preventDefault(); keys['punch'] = true; }, { passive: false });
        document.getElementById('punch-button').addEventListener('touchend', e =&gt; { e.preventDefault(); keys['punch'] = false; });
        
        const joystickStick = document.getElementById('joystick-stick');
        const joystickBase = document.getElementById('joystick-base');
        let joystick = { active: false, touchId: null, startX: 0, startY: 0, dirX: 0, dirY: 0 };

        gameContainer.addEventListener('touchstart', e =&gt; {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const target = touch.target;
                if (target === joystickBase || target === joystickStick) {
                     if (joystick.touchId === null) { 
                        joystick.touchId = touch.identifier; joystick.active = true;
                        joystick.startX = touch.clientX; joystick.startY = touch.clientY;
                    }
                } else { 
                     if (aimTouchId === null &amp;&amp; !target.classList.contains('control-button')) {
                        aimTouchId = touch.identifier;
                        updateAimPosition(touch.clientX, touch.clientY);
                        mouse.down = true;
                    }
                }
            }
        }, { passive: false });
        
        gameContainer.addEventListener('touchmove', e =&gt; {
            e.preventDefault();
            for (const touch of e.touches) { 
                if (touch.identifier === joystick.touchId) {
                    const deltaX=touch.clientX-joystick.startX, deltaY=touch.clientY-joystick.startY;
                    const dist=Math.sqrt(deltaX**2+deltaY**2), maxDelta=joystickBase.clientWidth/3;
                    let cX=deltaX, cY=deltaY;
                    if(dist&gt;maxDelta){cX=(deltaX/dist)*maxDelta;cY=(deltaY/dist)*maxDelta;}
                    joystickStick.style.transform=`translate(${cX}px,${cY}px)`;
                    joystick.dirX=cX/maxDelta;joystick.dirY=cY/maxDelta;
                } else if (touch.identifier === aimTouchId) {
                    updateAimPosition(touch.clientX, touch.clientY);
                }
            }
        }, { passive: false });

        gameContainer.addEventListener('touchend', e =&gt; {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === joystick.touchId) {
                    joystick.active=false;joystick.touchId=null;joystick.dirX=0;joystick.dirY=0;
                    joystickStick.style.transform=`translate(0px,0px)`;
                } else if (touch.identifier === aimTouchId) {
                    aimTouchId = null;
                    mouse.down = false;
                }
            }
        });
        
        // Download functionality
        document.getElementById('download-btn').addEventListener('click', () =&gt; {
            const gameHtml = document.documentElement.outerHTML;
            const blob = new Blob([gameHtml], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'doodle-shooter-game.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        resizeCanvas();
        generateLevel(currentLevel);
        updateUI();
        gameLoop();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
</body>
</html>
